namespace basilcc
{
   class BasilCC;

   // set goto on noterminals
   void setGoto(BasilCC &cc)
   {
      SymbolPtrVector const &nonterms = getNonTerminals(cc);
      std::for_each(nonterms.begin(), nonterms.end(), SetGoto(cc));
   }
}

using namespace basilcc;

namespace
{
   void SetGoto(BasilCC &cc; SymbolPtr symbol) const
   {
      NonTerminal &nonterm = static_cast<NonTerminal &>(*symbol);
      int symbol_num = nonterm.getNumber();
      ShiftStateVector shift_states;
      ShiftSelPtrVector const &shift_sels = getShiftSels(cc);
      for (ShiftSelPtrVectorConstIter i = shift_sels.begin(); i != shift_sels.end(); ++i)
      {
         ShiftSelPtr shift_sel = *i;
         if (StatePtr state = shift_sel->getShiftState(symbol_num))
         {
            shift_states.push_back(ShiftState(int(shift_sel->getNumber()), state));
         }
      }
      // will be empty for start symbol
      if (!shift_states.empty())
      {
         // find default state, sort by state then find state that occurs most
         std::sort(shift_states.begin(), shift_states.end(), shiftStateLessState);
         std::pair<ShiftStateVectorIter, ShiftStateVectorIter> dflt_shift_states = most(shift_states.begin(), shift_states.end(), shiftStateSameState);
         StatePtr dflt_state = dflt_shift_states.first->getState();
         // discard shift states with dflt_state 
         shift_states.erase(dflt_shift_states.first, dflt_shift_states.second);
         // reorder remaining by number
         std::sort(shift_states.begin(), shift_states.end(), shiftStateLessNumber);
         ShiftStateSelPtr shift_state_sel = getShiftStateSel(cc, shift_states);
         nonterm.setGoto(new Goto(shift_state_sel, dflt_state));
      }
   }
}

#src
#include <basilcc_goto.h>
#include <basilcc_shift.h>
#include <basilcc_shift_sel.h>
#include <basilcc_shift_sel_api.h>
#include <basilcc_shift_state_sel_api.h>
#include <basilcc_state.h>
#include <basilcc_symbol.h>
#include <basilcc_symbol_api.h>
#include <basilcc_util.h>
#include <algorithm>
#end
