// serialize finite state machine to lua code
namespace basilcc
{
   class BasilCC;

   // serialize to lua code in file
   void serialize(BasilCC &cc, std::string const &filename)
   {
      std::ofstream os(filename.c_str());
      if (!os)
      {
         std::ostringstream ss;
         ss << "failed to open " << filename;
         throw std::runtime_error(ss.str());
      }
      os << "-- Basil LR finite state machine\n";
      os << "-- Generated by the BasilCC parser generator\n";
      os << "-- Module returns table of node classes (do not extend classes here)\n";
      os << '\n';
      char const *module = "fsm";
      os << "local " << module << " = {}\n";
      os << '\n';
      writeNodeDefinitions(cc, module, os);
      os << "-- action constants\n";
      os << "local ACTION_SHIFT  = basil.ACTION_SHIFT\n";
      os << "local ACTION_REDUCE = basil.ACTION_REDUCE\n";
      os << "local ACTION_ACCEPT = basil.ACTION_ACCEPT\n";
      os << "local ACTION_DONE   = basil.ACTION_DONE\n";
      os << '\n';
      os << "-- initialize FSM\n";
      os << "basil.finite_state_machine {\n";
      writeNodes(cc, os);
      writeKeywords(cc, os);
      writeOperators(cc, os);
      writeRules(cc, os);
      writeActionSeqs(cc, os);
      writeMoveSels(cc, os);
      writeStates(cc, os);
      writeShiftStateSels(cc, os);
      writeGotos(cc, os);
      os << "}\n";
      os << '\n';
      os << "return " << module << '\n';
   }
}

using namespace basilcc;

namespace 
{
   // return string with i indent levels
   char const * _n(int i)
   {
      enum {MAXCHAR = 32};
      static char buf[MAXCHAR];
      i = std::min(MAXCHAR-1, i*3);
      std::fill((char *)buf, buf+i, ' ');
      buf[i] = '\0';
      return buf;
   }

   // print class definitions
   void writeNodeDefinitions(BasilCC const &cc, char const *module, std::ostream &os)
   {
      typedef std::multimap<NodePtr, RulePtr> RuleMultiMap;
      RuleMultiMap node_rules;
      {
         RulePtrVector const &rules = getRules(cc);
         for (RulePtrVectorConstIter i = rules.begin(), endi = rules.end(); i != endi; ++i)
         {
            RulePtr rule = *i;
            if (NodePtr node = rule->getNode())
            {
               node_rules.insert(std::make_pair(node, rule));
            }
         }
      }
      NodePtrVector const &nodes = getNodes(cc);
      for (NodePtrVector::const_iterator i = nodes.begin(), endi = nodes.end(); i != endi; ++i)
      {
         // in comment show all rules that share this node
         NodePtr node = *i;
         std::pair<RuleMultiMap::iterator, RuleMultiMap::iterator> r = node_rules.equal_range(node);
         for (RuleMultiMap::iterator j = r.first, endj = r.second; j != endj; ++j)
         {
            // keep simple here, don't show attributes on rule symbols
            os << "-- " << j->second->toString(Rule::NODOT, true) << '\n';
         }
         char const *name = node->getName();
         os << "local " << name << " = {}\n";
         // accept function
         os << "function " << name << ":accept(visitor)\n";
         os << "   return visitor:on" << name << "(self)\n";
         os << "end\n";
         os << module << '.' << name << " = " << name << '\n'; 
         os << '\n';
      }
   } 

   // node class definitions 
   void writeNodes(BasilCC const &cc, std::ostream &os)
   {
      NodePtrVector const &nodes = getNodes(cc);
      os << _n(1) << "nodes = {\n";
      for (NodePtrVector::const_iterator i = nodes.begin(), endi = nodes.end(); i != endi; ++i)
      {
         NodePtr node = *i;
         os << _n(2) << node->getName() << ",\n";
      }
      os << _n(1) << "},\n";
   }

   // keywords
   void writeKeywords(BasilCC const &cc, std::ostream &os)
   {
      SymbolPtrVector keywords = getKeywords(cc);
      if (keywords.empty())
      {
         return;
      }
      os << _n(1) << "keywords = {\n";
      for (SymbolPtrVector::const_iterator i = keywords.begin(), endi = keywords.end(); i != endi; ++i)
      {
         os << _n(2) << '\'' << static_cast<Token &>(**i).getLexeme() << "',\n";
      }
      os << _n(2) << "start = " << keywords.front()->getNumber() << ",\n";
      os << _n(1) << "},\n";
   }

   // operators
   void writeOperators(BasilCC const &cc, std::ostream &os)
   {
      SymbolPtrVector operators = getOperators(cc);
      os << _n(1) << "operators = {\n";
      for (SymbolPtrVector::const_iterator i = operators.begin(), endi = operators.end(); i != endi; ++i)
      {
         SymbolPtr token = *i;
         os << _n(2) << '\'' << token->getName() << "',\n";
      }
      os << _n(1) << "},\n";
   }

   // rules
   void writeRules(BasilCC &cc, std::ostream &os)
   {
      RulePtrVector const &rules = getRules(cc);
      os << _n(1) << "rules = {\n";
      for (RulePtrVector::const_iterator i = rules.begin(), endi = rules.end(); i != endi; ++i)
      {
         RulePtr rule = *i;
         // just size and node number 
         os << _n(2) << '{' << rule->getSize();
         NodePtr node = rule->getNode();
         if (node)
         {
            os << ", " << node->getNumber();
         }
         os << "},\n";
      }
      os << _n(1) << "},\n";
   }

   // action sequences
   void writeActionSeqs(BasilCC &cc, std::ostream &os)
   {
      os << _n(1) << "action_seqs = {\n"; 
      // write all actions together
      ActionSeqPtrVector const &action_seqs = getActionSeqs(cc);
      for (ActionSeqPtrVector::const_iterator i = action_seqs.begin(), endi = action_seqs.end(); i != endi; ++i)
      {
         ActionSeqPtr action_seq = *i;
         ActionPtrVector const &actions = action_seq->getActions();
         for (ActionPtrVector::const_iterator j = actions.begin(), endj = actions.end(); j != endj; ++j)
         {
            ActionPtr action = *j;
            os << _n(2) << '{';
            if (action->isReduction())
            {
               ReduceAction const &r_action = static_cast<ReduceAction const&>(*action);
               RulePtr rule = r_action.getRule();
               // done if reducing start rule
               if (rule->isStart())
               {
                  os << "ACTION_DONE";
               }
               else if (r_action.hasAccept())
               {
                  os << "ACTION_ACCEPT";
               }
               else
               {
                  os << "ACTION_REDUCE";
               }
               os << ", " << rule->getNumber() << ", " << r_action.getShortcut()->getNumber();
            }
            else
            {
               ShiftAction const &s_action = static_cast<ShiftAction const&>(*action);
               os << "ACTION_SHIFT" << ", " << s_action.getState()->getNumber();
            }
            os << "},\n";
         }
      }
      os << _n(2) << "seqs_end = {\n";
      int k = 0;
      for (ActionSeqPtrVector::const_iterator i = action_seqs.begin(), endi = action_seqs.end(); i != endi; ++i)
      {
         ActionSeqPtr action_seq = *i;
         k += action_seq->getActions().size();
         os << _n(3) << k << ",\n";
      }
      os << _n(2) << "},\n";
      os << _n(1) << "},\n";
   }

   // move selections
   void writeMoveSels(BasilCC const &cc, std::ostream &os)
   {
      MoveSelPtrVector const &move_sels = getMoveSels(cc);
      os << _n(1) << "move_sels = {\n";
      for (MoveSelPtrVector::const_iterator i = move_sels.begin(), endi = move_sels.end(); i != endi; ++i)
      {
         MoveSelPtr move_sel = *i;
         MovePtrVector const &moves = move_sel->getMoves();
         for (MovePtrVector::const_iterator j = moves.begin(), endj = moves.end(); j != endj; ++j)
         {
            MovePtr move = *j;
            os << _n(2) << '{' << move->getToken()->getNumber() << ", " << move->getActionSeq()->getNumber() << "},\n";
         }
      }
      os << _n(2) << "sels_end = {\n";
      int k = 0;
      for (MoveSelPtrVector::const_iterator i = move_sels.begin(), endi = move_sels.end(); i != endi; ++i)
      {
         MoveSelPtr move_sel = *i;
         k += move_sel->getMoves().size();
         os << _n(3) << k << ",\n";
      }
      os << _n(2) << "},\n";
      os << _n(1) << "},\n";
   }

   // states
   void writeStates(BasilCC const &cc, std::ostream &os)
   {
      StatePtrVector const &states = getStates(cc);
      os << _n(1) << "states = {\n";
      for (StatePtrVector::const_iterator i = states.begin(), endi = states.end(); i != endi; ++i)
      {
         StatePtr state = *i;
         StateMovePtr state_move = state->getStateMove();
         os << _n(2) << '{' << state_move->getMoveSel()->getNumber() 
            << ", " << state_move->getDefaultActionSeq()->getNumber()
            << ", " << state->getLexState().getState();
         ShiftSelPtr shift_sel = state->getNontermShiftSel();
         if (shift_sel)
         {
            os << ", " << shift_sel->getNumber();
         }
         os << "},\n";
      }
      os << _n(1) << "},\n";
   }

   // shift state sels
   void writeShiftStateSels(BasilCC const & cc, std::ostream &os)
   {
      ShiftStateSelPtrVector const &shift_state_sels = getShiftStateSels(cc);
      os << _n(1) << "shift_state_sels = {\n";
      for (ShiftStateSelPtrVector::const_iterator i = shift_state_sels.begin(), endi = shift_state_sels.end(); i != endi; ++i)
      {
         ShiftStateSelPtr shift_state_sel = *i;
         ShiftStateVector const &shift_states = shift_state_sel->getShiftStates();
         for (ShiftStateVector::const_iterator j = shift_states.begin(), endj = shift_states.end(); j != endj; ++j) 
         {
            ShiftState const &shift_state = *j;
            os << _n(2) << '{' << shift_state.getNumber() << ", " << shift_state.getState()->getNumber() << "},\n";
         }
      }
      os << _n(2) << "sels_end = {\n";
      int k = 0;
      for (ShiftStateSelPtrVector::const_iterator i = shift_state_sels.begin(), endi = shift_state_sels.end(); i != endi; ++i)
      {
         ShiftStateSelPtr shift_state_sel = *i;
         k += shift_state_sel->getShiftStates().size();
         os << _n(3) << k << ",\n";
      }
      os << _n(2) << "},\n";
      os << _n(1) << "},\n";
   }

   // nonterminal gotos
   void writeGotos(BasilCC const &cc, std::ostream &os)
   {
      SymbolPtrVector const &nonterms = getNonTerminals(cc);
      os << _n(1) << "gotos = {\n";
      for (SymbolPtrVector::const_iterator i = nonterms.begin(), endi = nonterms.end(); i != endi; ++i)
      {
         SymbolPtr nonterm = *i;
         GotoPtr go2 = static_cast<NonTerminal const&>(*nonterm).getGoto();
         os << _n(2) << '{';
         // goto not set for the start symbol
         if (go2)
         {
            os << go2->getShiftStateSel()->getNumber() << ", " << go2->getDefaultState()->getNumber();
         }
         os << "},\n";
      }
      os << _n(1) << "},\n";
   }
}

#hdr
#include <string>
#end

#src
#include <basilcc_action.h>
#include <basilcc_action_seq.h>
#include <basilcc_action_seq_api.h>
#include <basilcc_goto.h>
#include <basilcc_move.h>
#include <basilcc_move_sel.h>
#include <basilcc_move_sel_api.h>
#include <basilcc_node.h>
#include <basilcc_rule.h>
#include <basilcc_rule_api.h>
#include <basilcc_shift_sel.h>
#include <basilcc_shift_state_sel.h>
#include <basilcc_shift_state_sel_api.h>
#include <basilcc_state.h>
#include <basilcc_state_api.h>
#include <basilcc_state_move.h>
#include <basilcc_symbol.h>
#include <basilcc_symbol.h>
#include <basilcc_symbol_api.h>
#include <algorithm>
#include <fstream>
#include <limits>
#include <map>
#include <numeric>
#include <sstream>
#include <stdexcept>
#end
