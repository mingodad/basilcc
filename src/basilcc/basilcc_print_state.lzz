namespace basilcc
{
   class BasilCC;

   // print options
   enum
   {
      // kernel rules only
      PRINT_KERNEL_ONLY = 1 << 0,
      // shift rules
      PRINT_SHIFT       = 1 << 1,
      // follow rules
      PRINT_FOLLOW      = 1 << 2,
   };
  
   // print state to stream
   void printState(BasilCC &cc, StatePtr state, int flags, std::ostream &os)
   {
      // state number followed by lex state if non-zero
      os << state->getNumber();
      LexState lex_state = state->getLexState();
      if (lex_state.isConflict())
      {
         os << " (LEXICAL STATE CONFLICT)";
      }
      else if (lex_state.isSet())
      {
         os << " (" << lex_state.getState() << ')';
      }
      os << "\n-----\n";
      // conflicts
      FollowBasePtr follow_base = state->getFollowKernel()->getFollowBase();
      ConflictPtrVector const &conflicts = follow_base->getConflicts();
      if (!conflicts.empty())
      {
         std::for_each(conflicts.begin(), conflicts.end(), PrintConflict(os));
         os << '\n';
      }
      // rules
      bool kernel_only = flags & PRINT_KERNEL_ONLY;
      if (flags & PRINT_FOLLOW)
      {
         printFollowBase(follow_base, kernel_only, os);
      }
      else
      {
         ShiftBasePtr shift_base = follow_base->getShiftBase(); 
         printShiftBase(shift_base, !(flags & PRINT_SHIFT), kernel_only, os);
      }
      // shifts
      os << '\n';
      StateMovePtr state_move = state->getStateMove();
      MovePtrVector moves = state_move->getMoveSel()->getMoves();
      ActionPtrVector const &def_actions = state_move->getDefaultActionSeq()->getActions();
      if (!(moves.empty() && def_actions.empty()))
      {
         std::for_each(moves.begin(), moves.end(), PrintMove(os));
         if (!def_actions.empty()) 
         {
            std::string str = "* - ";
            appendActions(str, def_actions);
            os << str << '\n';
         }
         os << '\n';
      }
      // gotos
      ShiftSelPtr nonterm_shift_sel = state->getNontermShiftSel();
      if (nonterm_shift_sel)
      {
         ShiftPtrVector const &shifts = nonterm_shift_sel->getShifts();
         std::for_each(shifts.begin(), shifts.end(), PrintGoto(os));
         os << '\n';
      }
   }

   // print all states
   void printStates(BasilCC &cc, int flags, std::ostream &os)
   {
      StatePtrVector const &states = getStates(cc);
      for (StatePtrVectorConstIter i = states.begin(), endi = states.end(); i != endi; ++i)
      {
         printState(cc, *i, flags, os);
      }
   }
   void printStates(BasilCC &cc, int flags, std::string const &filename)
   {
      std::ofstream os(filename.c_str());
      if (!os)
      {
         std::ostringstream ss;
         ss << "failed to open " << filename;
         throw std::runtime_error(ss.str());
      }
      printStates(cc, flags, os);
   }
}

using namespace basilcc;

namespace
{
   void PrintConflict(std::ostream &os; ConflictPtr conflict) const
   {
      os << conflict->toString() << '\n';
   }

   void PrintMove(std::ostream &os; MovePtr move)
   {
      os << move->toString() << '\n';
   }

   void PrintGoto(std::ostream &os; ShiftPtr shift)
   {
      os << shift->getSymbol()->getName() << " - GOTO " << shift->getState()->getNumber() << '\n';
   }
}

#hdr
#include <basilcc_state_ptr.h>
#include <iosfwd>
#include <string>
#end

#src
#include <basilcc_action.h>
#include <basilcc_action_seq.h>
#include <basilcc_conflict.h>
#include <basilcc_follow_base.h>
#include <basilcc_follow_kernel.h>
#include <basilcc_move.h>
#include <basilcc_move_sel.h>
#include <basilcc_print_base.h>
#include <basilcc_shift.h>
#include <basilcc_shift_sel.h>
#include <basilcc_state.h>
#include <basilcc_state_api.h>
#include <basilcc_state_move.h>
#include <basilcc_symbol.h>
#include <algorithm>
#include <fstream>
#include <sstream>
#include <stdexcept>
#end
