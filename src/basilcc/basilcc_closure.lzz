// top level function to compile grammar to LR machine
namespace basilcc
{
   class BasilCC;

   // generate all states, set number of lexical state conflicts and return number of shift/reduce conflicts
   int closure(BasilCC &cc, int &num_lex_state_conflicts)
   {
      freezeKeywords(cc);
      freezeRules(cc);
      checkRules(cc);

      setFirst(cc);
      createStartStates(cc);
      StatePtrVector const &states = getStates(cc);
      num_lex_state_conflicts = 0;
      int num_conflicts = 0;
      for (unsigned i = 0; i < states.size(); ++ i)
      {
         StatePtr state = states[i];
         num_conflicts += state->closure(cc);
         if (state->getLexState().isConflict())
         {
            ++ num_lex_state_conflicts;
         }
      }
      if (num_conflicts == 0)
      {
         setGoto(cc);
      }
      return num_conflicts;
   }
}

using namespace basilcc;

namespace
{
   // create start states
   void createStartStates(BasilCC &cc)
   {
      RulePtrVector const &start_rules = getStartRules(cc);
      std::for_each(start_rules.begin(), start_rules.end(), CreateStartState(cc));
   }
   // create start state with start rule
   void CreateStartState(BasilCC &cc; RulePtr rule)
   {
      getStartState(cc, rule);
   }

   // create and return start state
   StatePtr getStartState(BasilCC &cc, RulePtr rule)
   {
      BaseRulePtr base_rule = getBaseRule(cc, rule);
      ShiftRulePtr shift_rule = getShiftRule(cc, base_rule, Priority());
      FollowRulePtrVector follow_rules(1, getFollowRule(cc, shift_rule, getStartFollow(cc, rule)));
      FollowKernelPtr follow_kernel = getFollowKernel(cc, follow_rules);
      return getState(cc, follow_kernel);
   }

   // get follow for start rule
   FollowPtr getStartFollow(BasilCC &cc, RulePtr rule)
   {
      std::auto_ptr<Follow> follow(new Follow());
      bool sticky = true, accept = true;
      SymbolPtr shortcut = getStartSymbol(cc);
      bool null = true;
      // only start rules may have explicit follow
      RuleSymbolPtrVector const &explicit_follow = rule->getExplicitFollow();
      if (! explicit_follow.empty())
      {
         null = false;
         for (RuleSymbolPtrVectorConstIter i = explicit_follow.begin(); i != explicit_follow.end(); ++ i)
         {
            RuleSymbolPtr rule_symbol = * i;
            SymbolPtr symbol = rule_symbol->getSymbol();
            First const &first = symbol->getFirst();
            follow->addFirst(first, rule_symbol->getLexState(), shortcut, rule_symbol->getFirstPriority(), sticky, accept);
            if (first.hasNull())
            {
               null = true;
            }
         }
      }
      if (null)
      {
         First const &first = getEOTSymbol(cc)->getFirst();
         follow->addFirst(first, LexState(), shortcut, Priority(), sticky, accept);
      }
      return freezeFollow(cc, follow.release());
   }
}

#src
#include <basilcc_base_rule_api.h>
#include <basilcc_check_rules.h>
#include <basilcc_follow.h>
#include <basilcc_follow_api.h>
#include <basilcc_follow_kernel_api.h>
#include <basilcc_follow_rule_api.h>
#include <basilcc_rule.h>
#include <basilcc_rule_api.h>
#include <basilcc_rule_symbol.h>
#include <basilcc_set_first.h>
#include <basilcc_set_goto.h>
#include <basilcc_shift_rule_api.h>
#include <basilcc_state.h>
#include <basilcc_state_api.h>
#include <basilcc_symbol.h>
#include <basilcc_symbol_api.h>
#include <algorithm>
#include <memory>
#end
