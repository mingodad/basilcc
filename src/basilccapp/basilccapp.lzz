// baislcc main
int main(int argc, char *argv[])
{
   try
   {
      // very simple command line parser
      std::string rules_filename, out_prefix;
      for (int i = 1; i < argc; ++i)
      {
         char const *arg = argv[i];
         if (arg[0] == '-')
         {
            // option
            ++arg;
            if (arg[0] == '\0')
            {
               throw std::runtime_error("stray '-'");
            }
            Option opt = OPT_NULL;
            if (!is_option(arg, opt))
            {
               std::ostringstream ss;
               ss << "not a valid option: " << arg;
               throw std::runtime_error(ss.str());
            }
            if (opt == OPT_HELP)
            {
               print_usage();
               return 0;
            }
            else
            {
               if (++i == argc)
               {
                  std::ostringstream ss;
                  ss << "option " << arg << " requires a value";
                  throw std::runtime_error(ss.str());
               }
               char const *value = argv[i];
               if (opt == OPT_OUT_PREFIX)
               {
                  out_prefix = value;
               }
            }
         }
         else
         {
            // otherwise rules filename
            if (!rules_filename.empty())
            {
               std::ostringstream ss;
               ss << "extra argument: " << arg;
               throw std::runtime_error(ss.str());
            }
            rules_filename = arg;
         }
      }
      if (rules_filename.empty())
      {
         throw std::runtime_error("missing rules filename");
      }

      std::string fsm_filename = "fsm.lua", states_filename = "states.txt";
      if (!out_prefix.empty())
      {
         if (is_directory(out_prefix))
         {
            fsm_filename = join(out_prefix, fsm_filename);
            states_filename = join(out_prefix, states_filename);
         }
         else
         {
            fsm_filename = out_prefix + fsm_filename;
            states_filename = out_prefix + states_filename;
         }
      }

      basilcc::BasilCC cc;
      if (!load_grammar(rules_filename, cc))
      {
         return 1;
      }
      int num_lex_state_conflicts = 0;
      int num_conflicts = basilcc::closure(cc, num_lex_state_conflicts);
      if (num_conflicts > 0 || num_lex_state_conflicts > 0)
      {
         std::cout << "Failed to generate parser" << std::endl;
         std::cout << num_conflicts << " parser and " << num_lex_state_conflicts << " lexical state conflicts" << std::endl;
         basilcc::printStates(cc, 0, states_filename);
         std::cout << "Wrote " << states_filename << std::endl;
      }
      else
      {
         std::cout << "Generated parser with " << getNumStates(cc) << " states" << std::endl;
         basilcc::serialize(cc, fsm_filename);
         basilcc::printStates(cc, 0, states_filename);
         std::cout << "Wrote " << fsm_filename << " and " << states_filename << std::endl;
      }
   }
   catch (std::exception const &e)
   {
      std::cout << e.what () << std::endl;
      return 1;
   }
   return 0;
}

using namespace basil;
using namespace basilcc;

namespace
{
   // parse grammar, load rules, return false if any errors   
   bool load_grammar(std::string const &rules_filename, basilcc::BasilCC &cc)
   {
      basil::Engine engine;
      engine.load(rule_lexer::token_numbers, rule_lexer::token_numbers_end, "basilcc");
      BasilCCLua cc_lua(engine.get_lua_state(), cc, std::cout); // registers basilcc api
      rule_lexer::RuleLexer lexer(cc, rules_filename);
      return engine.parse(0, lexer, std::cout) && !cc_lua.has_errors;
   }

   // print usage
   void print_usage()
   {
      std::cout << "Usage: basilcc [options] rules_filename\n"
                << "Basil Compiler Compiler\n"
                << "Options:\n"
                << " -h         display this help text\n"
                << " -p PREFIX  set output filename prefix\n"
                << "\n"
                << "Copyright(C) 2018 Michael Spencer; Lua Copyright(C) 1994-2016 Lua.org, PUC-Rio"
                << std::endl;
   }

   // command line options
   enum Option
   {
      OPT_NULL,
      OPT_OUT_PREFIX,
      OPT_HELP,
   };
   struct OptionTag
   {
      char const *tag;
      Option opt;
   };
   inline bool IsTag(std::string const &str; OptionTag const &option_tag) const
   {
      return option_tag.tag == str;
   }
   OptionTag option_tags[] =
   {
      { "p", OPT_OUT_PREFIX },
      { "h", OPT_HELP },
   };
   bool is_option(std::string const &str, Option &opt)
   {
      OptionTag const *i = option_tags, *endi = ARRAY_END(option_tags);
      if ((i = std::find_if(i, endi, IsTag(str))) != endi)
      {
         opt = i->opt;
         return true;
      }
      return false;
   }

   // true if filename is a directory
   bool is_directory(std::string const &filename)
   {
      struct stat fs;
      return stat(filename.c_str(), &fs) == 0 && S_ISDIR(fs.st_mode);
   }

   // join directory with filename
   std::string join(std::string const &dirname, std::string const &filename)
   {
      std::string result = dirname;
      size_t len = result.length();
      if (len > 0)
      {
         if (result[len-1] != '/')
         {
            result += '/';
         }
      }
      result += filename;
      return result;
   }
}

#src
#include <basilccapp_lexer.h>
#include <basilccapp_lua.h>
#include <basilcc_state_api.h>
#include <basilcc_basilcc.h>
#include <basilcc_closure.h>
#include <basilcc_print_state.h>
#include <basilcc_serialize.h>
#include <basil_engine.h>
#include <lauxlib.h>
#include <algorithm>
#include <iostream>
#include <sstream>
#include <stdexcept>
#include <sys/stat.h>

#define ARRAY_END(X) (X + sizeof(X)/sizeof(X[0]))
#end
