namespace basil
{
  typedef std::vector <int> IntVector;
  typedef std::pair <std::string, int> StringIntPair;
  typedef std::vector <StringIntPair> StringIntVector;
  typedef std::map <std::string, int> StringIntMap;

  // finite state machine
  class FSM
  {
  public:
    FSM (std::string const & fsm_filename, TokenNumberPtr oper_numbers_beg, TokenNumberPtr oper_numbers_end)
    {
      ifstream is (fsm_filename.c_str (), ios_base::in | ios_base::binary);
      if (! is)
      {
        throw runtime_error (Message ("failed to open parser FSM: %") << fsm_filename);
      }
      BinaryReader r (is);
      readKeywords (r);
      readNodes (r);
      readRules (r);
      readActionSeqs (r);
      readMoveSels (r, oper_numbers_beg, oper_numbers_end);
      readStates (r);
      readShiftStateSels (r);
      readGotos (r);
    }
    // types
    struct Rule (int size, int node) {}
    struct Move (int token, int action_seq) {}
    struct Action (int kind, int arg1, int arg2) {}
    struct State (int move_sel, int def_action_seq, int lex_state, int num) {}
    struct ShiftState (int num, int state) {}
    struct Goto (int shift_state_sel, int def_state) {}

    typedef std::vector <Rule> RuleVector;
    typedef Move const * MovePtr;
    typedef std::vector <Move> MoveVector;
    typedef std::vector <MovePtr> MovePtrVector;
    typedef Action const * ActionPtr;
    typedef std::vector <Action> ActionVector;
    typedef std::vector <ActionPtr> ActionPtrVector;
    typedef std::vector <State> StateVector;
    typedef ShiftState const * ShiftStatePtr;
    typedef std::vector <ShiftState> ShiftStateVector;
    typedef std::vector <ShiftStatePtr> ShiftStatePtrVector;
    typedef std::vector <Goto> GotoVector;

    // constants
    enum { REDUCE = 1, ACCEPT, SHIFT, DONE }
    enum { NOINDEX = -1 }

  protected:
    int m_num_start_rules;
    StringIntVector m_keywords;
    StringVector m_nodes;
    RuleVector m_rules;
    ActionVector m_action_seqs;
    ActionPtrVector m_action_seqs_beg;
    MoveVector m_move_sels;
    MovePtrVector m_move_sels_beg;
    StateVector m_states;
    ShiftStateVector m_shift_state_sels;
    ShiftStatePtrVector m_shift_state_sels_beg;
    GotoVector m_gotos;

  private:
    // keywords
    void readKeywords (BinaryReader & r)
    {
      StringVector lexemes;
      readStringVector (r, lexemes);
      if (! lexemes.empty ())
      {
        int start_number = r.readInt ();
        transform (lexemes.begin (), lexemes.end (), back_inserter (m_keywords), SetNumber (start_number));
      }
    }
    inline StringIntPair SetNumber (int number = 0; std::string & str)
    {
      return StringIntPair (str, number ++);
    }

    // nodes
    void readNodes (BinaryReader & r)
    {
      readStringVector (r, m_nodes);
    }

    // rules
    void readRules (BinaryReader & r)
    {
      int size = r.readInt ();
      m_num_start_rules = r.readInt ();
      m_rules.reserve (size);
      generate_n (back_inserter (m_rules), size, ReadRule (r));
    }
    inline FSM::Rule ReadRule (BinaryReader & r;) const
    {
      int size = r.readInt ();
      int node = r.readInt ();
      return Rule (size, node);
    }

    // actions
    void readActionSeqs (BinaryReader & r)
    {
      int size = r.readInt ();
      m_action_seqs.reserve (size);
      generate_n (back_inserter (m_action_seqs), size, ReadAction (r));
      IntVector nums;
      readVector (r, nums);
      m_action_seqs_beg.reserve (nums.size () + 1);
      m_action_seqs_beg.push_back (& m_action_seqs [0]);
      transform (nums.begin (), nums.end (), back_inserter (m_action_seqs_beg), GetActionPtr (m_action_seqs));
    }
    inline FSM::Action ReadAction (BinaryReader & r;) const
    {
      int kind = r.readInt ();
      int arg1 = r.readInt ();
      int arg2 = kind == SHIFT ? NOINDEX : r.readInt ();
      return Action (kind, arg1, arg2);
    }
    inline FSM::ActionPtr GetActionPtr (ActionVector const & actions; int num) const
    {
      return & actions [num];
    }

    // moves
    void readMoveSels (BinaryReader & r, TokenNumberPtr oper_numbers_beg, TokenNumberPtr oper_numbers_end)
    {
      // read operator names and get real operator numbers
      IntVector oper_numbers;
      readOperatorNames (r, oper_numbers_beg, oper_numbers_end, oper_numbers);
      // read all moves, filling in with real operator numbers
      int size = r.readInt ();
      m_move_sels.reserve (size);
      generate_n (back_inserter (m_move_sels), size, ReadMove (r, oper_numbers));
      // now move selections, just ptrs into moves
      IntVector nums;
      readVector (r, nums);
      m_move_sels_beg.reserve (nums.size () + 1);
      m_move_sels_beg.push_back (& m_move_sels [0]);
      transform (nums.begin (), nums.end (), back_inserter (m_move_sels_beg), GetMovePtr (m_move_sels));
      // finally have to resort moves in selection by token number since swapped operator numbers, can't assume still in order
      for (MovePtrVector::iterator i = m_move_sels_beg.begin (), j = i + 1, endj = m_move_sels_beg.end (); j != endj; i = j, ++ j)
      {
        Move * p = const_cast <Move *> (* i);
        Move * q = const_cast <Move *> (* j);
        sort (p, q, MoveTokenLess ());
        i = j; 
      }
    }
    // read operator names and using token numbers from lexer get real operator numbers
    void readOperatorNames (BinaryReader & r, TokenNumberPtr oper_numbers_beg, TokenNumberPtr oper_numbers_end, IntVector & numbers)
    {
      StringVector names;
      readStringVector (r, names);
      // create copy of operator names and acutal number pairs, and sort by name for easy lookup
      typedef vector <TokenNumber> TokenNumberVector;
      TokenNumberVector oper_numbers (oper_numbers_beg, oper_numbers_end);
      sort (oper_numbers.begin (), oper_numbers.end (), tokenNumberNameLess1);
      numbers.reserve (names.size ());
      // for each operator in grammar lookup real number
      for (StringVector::const_iterator i = names.begin (), endi = names.end (); i != endi; ++ i)
      {
        string const & name = * i;
        TokenNumberVector::iterator t = lower_bound (oper_numbers.begin (), oper_numbers.end (), name, tokenNumberNameLess2);
        if (t == oper_numbers.end () || t->name != name)
        {
          throw runtime_error (Message ("Token number not provided for %") << name);
        }
        numbers.push_back (t->num);
      }
    }
    // read move
    inline FSM::Move ReadMove (BinaryReader & r, IntVector const & numbers;) const
    {
      int token = r.readInt ();
      if (token < int (numbers.size ()))
      {
        token = numbers [token];
      }
      int action_seq_num = r.readInt (); 
      return Move (token, action_seq_num);
    }
    inline FSM::MovePtr GetMovePtr (MoveVector const & moves; int num) const
    {
      return & moves [num];
    }

    // states
    void readStates (BinaryReader & r)
    {
      int size = r.readInt ();
      m_states.reserve (size);
      generate_n (back_inserter (m_states), size, ReadState (r));
    }
    inline FSM::State ReadState (BinaryReader & r;) const
    {
      int move_sel = r.readInt ();
      int def_action_seq = r.readInt ();
      int lex_state = r.readInt ();
      int num = r.readInt ();
      return State (move_sel, def_action_seq, lex_state, num);
    }

    // shift states
    void readShiftStateSels (BinaryReader & r)
    {
      int size = r.readInt ();
      m_shift_state_sels.reserve (size);
      generate_n (back_inserter (m_shift_state_sels), size, ReadShiftState (r));
      IntVector nums;
      readVector (r, nums);
      m_shift_state_sels_beg.reserve (nums.size () + 1);
      m_shift_state_sels_beg.push_back (& m_shift_state_sels [0]);
      transform (nums.begin (), nums.end (), back_inserter (m_shift_state_sels_beg), GetShiftStatePtr (m_shift_state_sels));
    }
    inline FSM::ShiftState ReadShiftState (BinaryReader & r;) const
    {
      int num = r.readInt ();
      int state = r.readInt ();
      return ShiftState (num, state);
    }
    inline FSM::ShiftStatePtr GetShiftStatePtr (ShiftStateVector const & shift_states; int num) const
    {
      return & shift_states [num];
    }

    // and gotos
    void readGotos (BinaryReader & r)
    {
      int size = r.readInt ();
      m_gotos.reserve (size);
      generate_n (back_inserter (m_gotos), size, ReadGoto (r));
    }
    inline FSM::Goto ReadGoto (BinaryReader & r;) const
    {
      int shift_state_sel = r.readInt ();
      int def_state = r.readInt (); 
      return Goto (shift_state_sel, def_state);
    }
  }
}

using namespace std;
using namespace basil;

namespace
{
  // true if token number name less
  bool tokenNumberNameLess1 (TokenNumber const & a, TokenNumber const & b)
  {
    return strcmp (a.name, b.name) < 0;
  }
  bool tokenNumberNameLess2 (TokenNumber const & a, string const & name)
  {
    return a.name < name;
  }

  // true if move token less
  inline bool MoveTokenLess (; FSM::Move const & a, FSM::Move const & b) const
  {
    return a.token < b.token;
  }
}

#hdr
#include <basil/bstream.h>
#include <basil/token_number.h>
#include <vector>
#include <map>
#end

#src
#include <basil/message.h>
#include <algorithm>
#include <cstring>
#include <fstream>
#include <limits>
#include <stdexcept>
#end
